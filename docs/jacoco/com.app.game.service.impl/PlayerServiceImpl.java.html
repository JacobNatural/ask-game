<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="pl"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PlayerServiceImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Ask_Game_Maven</a> &gt; <a href="index.source.html" class="el_package">com.app.game.service.impl</a> &gt; <span class="el_source">PlayerServiceImpl.java</span></div><h1>PlayerServiceImpl.java</h1><pre class="source lang-java linenums">package com.app.game.service.impl;

import com.app.game.service.PlayerService;
import com.app.player.Player;
import com.app.player.PlayerMapper;
import com.app.repository.PlayerRepository;
import com.app.txt.save.FileWriter;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

/**
 * Service implementation for managing player-related operations.
 *
 * &lt;p&gt;This class provides methods for adding, removing, finding, and saving players,
 * as well as generating rankings and filtering players by specific periods.
 */
@Service
@RequiredArgsConstructor
public class PlayerServiceImpl implements PlayerService {
    private final PlayerRepository&lt;Long&gt; playerRepository;
    private final FileWriter&lt;Player&gt; playerFileWriter;

    /**
     * Adds a new player to the repository.
     *
     * @param player the {@link Player} object to be added
     * @throws IllegalArgumentException if the player is {@code null} or already exists in the repository
     */
    @Override
    public void addPlayer(Player player) {
<span class="fc bfc" id="L36" title="All 2 branches covered.">        if (player == null) {</span>
<span class="fc" id="L37">            throw new IllegalArgumentException(&quot;Player cannot be null&quot;);</span>
        }

<span class="fc bfc" id="L40" title="All 2 branches covered.">        if (playerRepository.containsValue(player)) {</span>
<span class="fc" id="L41">            throw new IllegalArgumentException(&quot;Player already exists&quot;);</span>
        }

<span class="fc" id="L44">        playerRepository.addPlayer(player);</span>
<span class="fc" id="L45">    }</span>

    /**
     * Removes a player from the repository by ID.
     *
     * @param id the unique ID of the player to be removed
     * @throws IllegalArgumentException if the player with the specified ID is not found
     */
    @Override
    public void removePlayer(Long id) {
<span class="fc bfc" id="L55" title="All 2 branches covered.">        if (!playerRepository.containsID(id)) {</span>
<span class="fc" id="L56">            throw new IllegalArgumentException(&quot;Player not found&quot;);</span>
        }
<span class="fc" id="L58">        playerRepository.removeByID(id);</span>
<span class="fc" id="L59">    }</span>

    /**
     * Saves the current list of players to a text file using a specified format.
     *
     * @param filename    the name of the file where players will be saved
     * @param toTxtFormat a function that converts a {@link Player} object to a text format
     * @throws IllegalArgumentException if the {@code toTxtFormat} function is {@code null}
     */
    @Override
    public void savePlayerToTxt(String filename, Function&lt;Player, String&gt; toTxtFormat) {
<span class="fc bfc" id="L70" title="All 2 branches covered.">        if (toTxtFormat == null) {</span>
<span class="fc" id="L71">            throw new IllegalArgumentException(&quot;ToTxtFormat cannot be null&quot;);</span>
        }
<span class="fc" id="L73">        playerFileWriter.save(filename, playerRepository.getPlayers(), toTxtFormat);</span>
<span class="fc" id="L74">    }</span>

    /**
     * Finds a player by their unique ID.
     *
     * @param playerId the unique ID of the player
     * @return the {@link Player} object if found
     * @throws IllegalArgumentException if the player is not found
     */
    @Override
    public Player findPlayer(Long playerId) {
<span class="fc bfc" id="L85" title="All 2 branches covered.">        if (!playerRepository.containsID(playerId)) {</span>
<span class="fc" id="L86">            throw new IllegalArgumentException(&quot;Player not found&quot;);</span>
        }
<span class="fc" id="L88">        return playerRepository.findByID(playerId);</span>
    }

    /**
     * Retrieves the player(s) with the best score from the repository.
     *
     * @return a list of {@link Player} objects with the highest score
     */
    @Override
    public List&lt;Player&gt; getTheBestPlayer() {
<span class="fc" id="L98">        return getTheBestPlayer(playerRepository.getPlayers());</span>
    }

    /**
     * Checks if the repository contains a player with the given ID.
     *
     * @param playerID the unique ID of the player
     * @return {@code true} if the player exists, {@code false} otherwise
     */
    @Override
    public boolean containID(Long playerID) {
<span class="fc" id="L109">        return playerRepository.containsID(playerID);</span>
    }

    /**
     * Retrieves the best player(s) within a specific time period.
     *
     * @param from the start date of the period
     * @param to   the end date of the period
     * @return a list of {@link Player} objects with the highest score in the specified period
     * @throws IllegalArgumentException if {@code from} or {@code to} is {@code null}, or if {@code from} is after {@code to}
     */
    @Override
    public List&lt;Player&gt; getTheBestPlayerInPeriod(LocalDateTime from, LocalDateTime to) {
<span class="fc bfc" id="L122" title="All 2 branches covered.">        if (from == null) {</span>
<span class="fc" id="L123">            throw new IllegalArgumentException(&quot;Start date cannot be null&quot;);</span>
        }

<span class="fc bfc" id="L126" title="All 2 branches covered.">        if (to == null) {</span>
<span class="fc" id="L127">            throw new IllegalArgumentException(&quot;End date cannot be null&quot;);</span>
        }

<span class="fc bfc" id="L130" title="All 2 branches covered.">        if (from.isAfter(to)) {</span>
<span class="fc" id="L131">            throw new IllegalArgumentException(&quot;Start date cannot be after end date&quot;);</span>
        }

<span class="fc" id="L134">        var playersInPeriod = getPlayersFilterByPeriod(from, to);</span>

<span class="fc" id="L136">        return getTheBestPlayer(playersInPeriod);</span>
    }

    /**
     * Generates a ranking of players based on their best scores.
     *
     * @return a map where the key is the score and the value is a set of player logins, sorted in descending order by score
     */
    @Override
    public Map&lt;Integer, Set&lt;String&gt;&gt; getRankingOfPlayers() {
<span class="fc" id="L146">        return playerRepository</span>
<span class="fc" id="L147">                .getPlayers()</span>
<span class="fc" id="L148">                .stream()</span>
<span class="fc" id="L149">                .collect(Collectors.groupingBy(Player::getTheBestScore,</span>
<span class="fc" id="L150">                        Collectors.mapping(PlayerMapper.toLogin, Collectors.toSet())))</span>
<span class="fc" id="L151">                .entrySet()</span>
<span class="fc" id="L152">                .stream()</span>
<span class="fc" id="L153">                .sorted((m1, m2) -&gt; Integer.compare(m2.getKey(), m1.getKey()))</span>
<span class="fc" id="L154">                .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue,</span>
<span class="nc" id="L155">                        (v1, v2) -&gt; v1, LinkedHashMap::new));</span>
    }

    /**
     * Retrieves the player(s) with the best score from the given list of players.
     *
     * @param players the list of {@link Player} objects to evaluate
     * @return a list of {@link Player} objects with the highest score
     * @throws IllegalArgumentException if the list of players is empty
     */
    private static List&lt;Player&gt; getTheBestPlayer(List&lt;Player&gt; players) {
<span class="fc" id="L166">        return players</span>
<span class="fc" id="L167">                .stream()</span>
<span class="fc" id="L168">                .collect(Collectors.groupingBy(Player::getTheBestScore))</span>
<span class="fc" id="L169">                .entrySet()</span>
<span class="fc" id="L170">                .stream()</span>
<span class="fc" id="L171">                .max(Map.Entry.comparingByKey())</span>
<span class="fc" id="L172">                .map(Map.Entry::getValue)</span>
<span class="fc" id="L173">                .orElseThrow(() -&gt; new IllegalArgumentException(&quot;Repository is empty&quot;));</span>
    }

    /**
     * Filters players by a given time period.
     *
     * @param from the start date of the period
     * @param to   the end date of the period
     * @return a list of {@link Player} objects whose activities fall within the specified period
     */
    private List&lt;Player&gt; getPlayersFilterByPeriod(LocalDateTime from, LocalDateTime to) {
<span class="fc" id="L184">        return playerRepository</span>
<span class="fc" id="L185">                .getPlayers()</span>
<span class="fc" id="L186">                .stream()</span>
<span class="fc" id="L187">                .map(player -&gt; player.filterByPeriod(from, to))</span>
<span class="fc" id="L188">                .filter(Objects::nonNull)</span>
<span class="fc" id="L189">                .toList();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>